{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState, useRef, useCallback } from 'react';\nimport { ACTIONS } from '../actions';\nimport socketInit from '../socket';\nimport freeice from 'freeice';\nimport { useStateWithCallback } from './useStateWithCallback';\nexport const useWebRTC = (roomId, user) => {\n  _s();\n\n  const [clients, setClients] = useStateWithCallback([]);\n  const audioElements = useRef({});\n  const connections = useRef({});\n  const socket = useRef(null);\n  const localMediaStream = useRef(null);\n  const clientsRef = useRef([]);\n  const addNewClient = useCallback((newClient, cb) => {\n    const lookingFor = clients.find(client => client.id === newClient.id);\n    console.log('clients', clients, lookingFor);\n\n    if (lookingFor === undefined) {\n      setClients(existingClients => [...existingClients, newClient], cb);\n    }\n  }, [clients, setClients]);\n  useEffect(() => {\n    socket.current = socketInit();\n  }, []); // Handle new peer\n\n  useEffect(() => {\n    const handleNewPeer = async _ref => {\n      let {\n        peerId,\n        createOffer,\n        user: remoteUser\n      } = _ref;\n\n      // If already connected then prevent connecting again\n      if (peerId in connections.current) {\n        return console.warn(`You are already connected with ${peerId} (${user.name})`);\n      } // Store it to connections\n\n\n      connections.current[peerId] = new RTCPeerConnection({\n        iceServers: freeice()\n      }); // Handle new ice candidate on this peer connection\n\n      connections.current[peerId].onicecandidate = event => {\n        socket.current.emit(ACTIONS.RELAY_ICE, {\n          peerId,\n          icecandidate: event.candidate\n        });\n      }; // Handle on track event on this connection\n\n\n      connections.current[peerId].ontrack = _ref2 => {\n        let {\n          streams: [remoteStream]\n        } = _ref2;\n        addNewClient({ ...remoteUser,\n          muted: true\n        }, () => {\n          // console.log('peer', audioElements.current, peerId);\n          if (audioElements.current[remoteUser.id]) {\n            audioElements.current[remoteUser.id].srcObject = remoteStream;\n          } else {\n            let settled = false;\n            const interval = setInterval(() => {\n              if (audioElements.current[remoteUser.id]) {\n                audioElements.current[remoteUser.id].srcObject = remoteStream;\n                settled = true;\n              }\n\n              if (settled) {\n                clearInterval(interval);\n              }\n            }, 1000);\n          }\n        });\n      }; // Add connection to peer connections track\n\n\n      localMediaStream.current.getTracks().forEach(track => {\n        connections.current[peerId].addTrack(track, localMediaStream.current);\n      }); // Create an offer if required\n\n      if (createOffer) {\n        const offer = await connections.current[peerId].createOffer(); // Set as local description\n\n        await connections.current[peerId].setLocalDescription(offer); // send offer to the server\n\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: offer\n        });\n      }\n    }; // Listen for add peer event from ws\n\n\n    socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\n    return () => {\n      socket.current.off(ACTIONS.ADD_PEER);\n    };\n  }, [clients]);\n  useEffect(() => {\n    const startCapture = async () => {\n      // Start capturing local audio stream.\n      localMediaStream.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n    };\n\n    startCapture().then(() => {\n      // add user to clients list\n      addNewClient({ ...user,\n        muted: true\n      }, () => {\n        const localElement = audioElements.current[user.id];\n\n        if (localElement) {\n          localElement.volume = 0;\n          localElement.srcObject = localMediaStream.current;\n        }\n      }); // Emit the action to join\n\n      socket.current.emit(ACTIONS.JOIN, {\n        roomId,\n        user\n      });\n    }); // Leaving the room\n\n    return () => {\n      localMediaStream.current.getTracks().forEach(track => track.stop());\n      socket.current.emit(ACTIONS.LEAVE, {\n        roomId\n      });\n    };\n  }, []); // Handle ice candidate\n\n  useEffect(() => {\n    socket.current.on(ACTIONS.ICE_CANDIDATE, _ref3 => {\n      let {\n        peerId,\n        icecandidate\n      } = _ref3;\n\n      // console.log('ices', connections.current[peerId]);\n      if (icecandidate) {\n        connections.current[peerId].addIceCandidate(icecandidate);\n      }\n    });\n    return () => {\n      socket.current.off(ACTIONS.ICE_CANDIDATE);\n    };\n  }, []); // Handle session description\n\n  useEffect(() => {\n    const setRemoteMedia = async _ref4 => {\n      let {\n        peerId,\n        sessionDescription: remoteSessionDescription\n      } = _ref4;\n      connections.current[peerId].setRemoteDescription(new RTCSessionDescription(remoteSessionDescription)); // If session descrition is offer then create an answer\n\n      if (remoteSessionDescription.type === 'offer') {\n        const connection = connections.current[peerId];\n        const answer = await connection.createAnswer();\n        connection.setLocalDescription(answer);\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: answer\n        });\n      }\n    };\n\n    socket.current.on(ACTIONS.SESSION_DESCRIPTION, setRemoteMedia);\n    return () => {\n      socket.current.off(ACTIONS.SESSION_DESCRIPTION);\n    };\n  }, []);\n  useEffect(() => {\n    window.addEventListener('unload', function () {\n      alert('leaving');\n      socket.current.emit(ACTIONS.LEAVE, {\n        roomId\n      });\n    });\n  }, []);\n  useEffect(() => {\n    const handleRemovePeer = _ref5 => {\n      let {\n        peerID,\n        userId\n      } = _ref5;\n      console.log('leaving', peerID, userId);\n\n      if (connections.current[peerID]) {\n        connections.current[peerID].close();\n      }\n\n      delete connections.current[peerID];\n      delete audioElements.current[peerID];\n      setClients(list => list.filter(c => c.id !== userId));\n    };\n\n    socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\n    return () => {\n      socket.current.off(ACTIONS.REMOVE_PEER);\n    };\n  }, []);\n  useEffect(() => {\n    // handle mute and unmute\n    socket.current.on(ACTIONS.MUTE, _ref6 => {\n      let {\n        peerId,\n        userId\n      } = _ref6;\n      console.log('muting', userId);\n      setMute(true, userId);\n    });\n    socket.current.on(ACTIONS.UNMUTE, _ref7 => {\n      let {\n        peerId,\n        userId\n      } = _ref7;\n      console.log('unmuting', userId);\n      setMute(false, userId);\n    });\n\n    const setMute = (mute, userId) => {\n      const clientIdx = clientsRef.current.map(client => client.id).indexOf(userId);\n      console.log('idx', clientIdx); // const connectedClients = clientsRef.current.filter(\n      //     (client) => client.id !== userId\n      // );\n\n      const connectedClientsClone = JSON.parse(JSON.stringify(clientsRef.current));\n\n      if (clientIdx > -1) {\n        connectedClientsClone[clientIdx].muted = mute;\n        console.log('muuuu', connectedClientsClone);\n        setClients(_ => connectedClientsClone);\n      }\n    };\n  }, []);\n\n  const provideRef = (instance, userId) => {\n    audioElements.current[userId] = instance;\n  };\n\n  useEffect(() => {\n    clientsRef.current = clients;\n  }, [clients]);\n\n  const handleMute = (isMute, userId) => {\n    let settled = false;\n\n    if (userId === user.id) {\n      let interval = setInterval(() => {\n        if (localMediaStream.current) {\n          localMediaStream.current.getTracks()[0].enabled = !isMute;\n\n          if (isMute) {\n            socket.current.emit(ACTIONS.MUTE, {\n              roomId,\n              userId: user.id\n            });\n          } else {\n            socket.current.emit(ACTIONS.UNMUTE, {\n              roomId,\n              userId: user.id\n            });\n          } // console.log(\n          //     'localMediaStream ',\n          //     localMediaStream.current.getTracks()\n          // );\n\n\n          settled = true;\n        }\n\n        if (settled) {\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  };\n\n  return {\n    clients,\n    provideRef,\n    handleMute,\n    localStream: localMediaStream.current\n  };\n};\n\n_s(useWebRTC, \"nxqI+Xhxernb2eblwxzywPmWVzQ=\", false, function () {\n  return [useStateWithCallback];\n});","map":{"version":3,"sources":["C:/Users/neha/Downloads/codershouse-mern-prep/frontend/src/hooks/useWebRTC.js"],"names":["useEffect","useState","useRef","useCallback","ACTIONS","socketInit","freeice","useStateWithCallback","useWebRTC","roomId","user","clients","setClients","audioElements","connections","socket","localMediaStream","clientsRef","addNewClient","newClient","cb","lookingFor","find","client","id","console","log","undefined","existingClients","current","handleNewPeer","peerId","createOffer","remoteUser","warn","name","RTCPeerConnection","iceServers","onicecandidate","event","emit","RELAY_ICE","icecandidate","candidate","ontrack","streams","remoteStream","muted","srcObject","settled","interval","setInterval","clearInterval","getTracks","forEach","track","addTrack","offer","setLocalDescription","RELAY_SDP","sessionDescription","on","ADD_PEER","off","startCapture","navigator","mediaDevices","getUserMedia","audio","then","localElement","volume","JOIN","stop","LEAVE","ICE_CANDIDATE","addIceCandidate","setRemoteMedia","remoteSessionDescription","setRemoteDescription","RTCSessionDescription","type","connection","answer","createAnswer","SESSION_DESCRIPTION","window","addEventListener","alert","handleRemovePeer","peerID","userId","close","list","filter","c","REMOVE_PEER","MUTE","setMute","UNMUTE","mute","clientIdx","map","indexOf","connectedClientsClone","JSON","parse","stringify","_","provideRef","instance","handleMute","isMute","enabled","localStream"],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef, useCallback } from 'react';\nimport { ACTIONS } from '../actions';\nimport socketInit from '../socket';\nimport freeice from 'freeice';\nimport { useStateWithCallback } from './useStateWithCallback';\n\nexport const useWebRTC = (roomId, user) => {\n    const [clients, setClients] = useStateWithCallback([]);\n    const audioElements = useRef({});\n    const connections = useRef({});\n    const socket = useRef(null);\n    const localMediaStream = useRef(null);\n    const clientsRef = useRef([]);\n\n    const addNewClient = useCallback(\n        (newClient, cb) => {\n            const lookingFor = clients.find(\n                (client) => client.id === newClient.id\n            );\n\n            console.log('clients', clients, lookingFor);\n            if (lookingFor === undefined) {\n                setClients(\n                    (existingClients) => [...existingClients, newClient],\n                    cb\n                );\n            }\n        },\n        [clients, setClients]\n    );\n\n    useEffect(() => {\n        socket.current = socketInit();\n    }, []);\n\n    // Handle new peer\n\n    useEffect(() => {\n        const handleNewPeer = async ({\n            peerId,\n            createOffer,\n            user: remoteUser,\n        }) => {\n            // If already connected then prevent connecting again\n            if (peerId in connections.current) {\n                return console.warn(\n                    `You are already connected with ${peerId} (${user.name})`\n                );\n            }\n\n            // Store it to connections\n            connections.current[peerId] = new RTCPeerConnection({\n                iceServers: freeice(),\n            });\n\n            // Handle new ice candidate on this peer connection\n            connections.current[peerId].onicecandidate = (event) => {\n                socket.current.emit(ACTIONS.RELAY_ICE, {\n                    peerId,\n                    icecandidate: event.candidate,\n                });\n            };\n\n            // Handle on track event on this connection\n            connections.current[peerId].ontrack = ({\n                streams: [remoteStream],\n            }) => {\n                addNewClient({ ...remoteUser, muted: true }, () => {\n                    // console.log('peer', audioElements.current, peerId);\n\n                    if (audioElements.current[remoteUser.id]) {\n                        audioElements.current[remoteUser.id].srcObject =\n                            remoteStream;\n                    } else {\n                        let settled = false;\n                        const interval = setInterval(() => {\n                            if (audioElements.current[remoteUser.id]) {\n                                audioElements.current[remoteUser.id].srcObject =\n                                    remoteStream;\n                                settled = true;\n                            }\n\n                            if (settled) {\n                                clearInterval(interval);\n                            }\n                        }, 1000);\n                    }\n                });\n            };\n\n            // Add connection to peer connections track\n            localMediaStream.current.getTracks().forEach((track) => {\n                connections.current[peerId].addTrack(\n                    track,\n                    localMediaStream.current\n                );\n            });\n\n            // Create an offer if required\n            if (createOffer) {\n                const offer = await connections.current[peerId].createOffer();\n\n                // Set as local description\n                await connections.current[peerId].setLocalDescription(offer);\n\n                // send offer to the server\n                socket.current.emit(ACTIONS.RELAY_SDP, {\n                    peerId,\n                    sessionDescription: offer,\n                });\n            }\n        };\n\n        // Listen for add peer event from ws\n        socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\n        return () => {\n            socket.current.off(ACTIONS.ADD_PEER);\n        };\n    }, [clients]);\n\n    useEffect(() => {\n        const startCapture = async () => {\n            // Start capturing local audio stream.\n\n            localMediaStream.current =\n                await navigator.mediaDevices.getUserMedia({\n                    audio: true,\n                });\n        };\n\n        startCapture().then(() => {\n            // add user to clients list\n            addNewClient({ ...user, muted: true }, () => {\n                const localElement = audioElements.current[user.id];\n                if (localElement) {\n                    localElement.volume = 0;\n                    localElement.srcObject = localMediaStream.current;\n                }\n            });\n\n            // Emit the action to join\n            socket.current.emit(ACTIONS.JOIN, {\n                roomId,\n                user,\n            });\n        });\n\n        // Leaving the room\n        return () => {\n            localMediaStream.current\n                .getTracks()\n                .forEach((track) => track.stop());\n            socket.current.emit(ACTIONS.LEAVE, { roomId });\n        };\n    }, []);\n\n    // Handle ice candidate\n    useEffect(() => {\n        socket.current.on(ACTIONS.ICE_CANDIDATE, ({ peerId, icecandidate }) => {\n            // console.log('ices', connections.current[peerId]);\n            if (icecandidate) {\n                connections.current[peerId].addIceCandidate(icecandidate);\n            }\n        });\n\n        return () => {\n            socket.current.off(ACTIONS.ICE_CANDIDATE);\n        };\n    }, []);\n\n    // Handle session description\n\n    useEffect(() => {\n        const setRemoteMedia = async ({\n            peerId,\n            sessionDescription: remoteSessionDescription,\n        }) => {\n            connections.current[peerId].setRemoteDescription(\n                new RTCSessionDescription(remoteSessionDescription)\n            );\n\n            // If session descrition is offer then create an answer\n            if (remoteSessionDescription.type === 'offer') {\n                const connection = connections.current[peerId];\n\n                const answer = await connection.createAnswer();\n                connection.setLocalDescription(answer);\n\n                socket.current.emit(ACTIONS.RELAY_SDP, {\n                    peerId,\n                    sessionDescription: answer,\n                });\n            }\n        };\n\n        socket.current.on(ACTIONS.SESSION_DESCRIPTION, setRemoteMedia);\n        return () => {\n            socket.current.off(ACTIONS.SESSION_DESCRIPTION);\n        };\n    }, []);\n\n    useEffect(() => {\n        window.addEventListener('unload', function () {\n            alert('leaving');\n            socket.current.emit(ACTIONS.LEAVE, { roomId });\n        });\n    }, []);\n\n    useEffect(() => {\n        const handleRemovePeer = ({ peerID, userId }) => {\n            console.log('leaving', peerID, userId);\n\n            if (connections.current[peerID]) {\n                connections.current[peerID].close();\n            }\n\n            delete connections.current[peerID];\n            delete audioElements.current[peerID];\n\n            setClients((list) => list.filter((c) => c.id !== userId));\n        };\n\n        socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\n\n        return () => {\n            socket.current.off(ACTIONS.REMOVE_PEER);\n        };\n    }, []);\n\n    useEffect(() => {\n        // handle mute and unmute\n        socket.current.on(ACTIONS.MUTE, ({ peerId, userId }) => {\n            console.log('muting', userId);\n            setMute(true, userId);\n        });\n\n        socket.current.on(ACTIONS.UNMUTE, ({ peerId, userId }) => {\n            console.log('unmuting', userId);\n            setMute(false, userId);\n        });\n\n        const setMute = (mute, userId) => {\n            const clientIdx = clientsRef.current\n                .map((client) => client.id)\n                .indexOf(userId);\n\n            console.log('idx', clientIdx);\n\n            // const connectedClients = clientsRef.current.filter(\n            //     (client) => client.id !== userId\n            // );\n\n            const connectedClientsClone = JSON.parse(\n                JSON.stringify(clientsRef.current)\n            );\n\n            if (clientIdx > -1) {\n                connectedClientsClone[clientIdx].muted = mute;\n                console.log('muuuu', connectedClientsClone);\n                setClients((_) => connectedClientsClone);\n            }\n        };\n    }, []);\n\n    const provideRef = (instance, userId) => {\n        audioElements.current[userId] = instance;\n    };\n\n    useEffect(() => {\n        clientsRef.current = clients;\n    }, [clients]);\n\n    const handleMute = (isMute, userId) => {\n        let settled = false;\n\n        if (userId === user.id) {\n            let interval = setInterval(() => {\n                if (localMediaStream.current) {\n                    localMediaStream.current.getTracks()[0].enabled = !isMute;\n                    if (isMute) {\n                        socket.current.emit(ACTIONS.MUTE, {\n                            roomId,\n                            userId: user.id,\n                        });\n                    } else {\n                        socket.current.emit(ACTIONS.UNMUTE, {\n                            roomId,\n                            userId: user.id,\n                        });\n                    }\n                    // console.log(\n                    //     'localMediaStream ',\n                    //     localMediaStream.current.getTracks()\n                    // );\n                    settled = true;\n                }\n                if (settled) {\n                    clearInterval(interval);\n                }\n            }, 200);\n        }\n    };\n\n    return {\n        clients,\n        provideRef,\n        handleMute,\n        localStream: localMediaStream.current,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}